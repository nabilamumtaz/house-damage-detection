# -*- coding: utf-8 -*-
"""Klasifikasi Rumah Rusak.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i51MJh3xPeKsnwVnvApLxbPJ843dvKFO

### Melatih Sistem Deteksi Kerusakan Bangunan 🏠

#### Kami menggunakan dataset gambar yang terbagi ke dalam tiga kategori utama untuk melatih sistem deteksi kerusakan bangunan. Setiap kategori merepresentasikan tingkat kerusakan tertentu dan membantu model mempelajari pola visual khas dari setiap kondisi bangunan.

#### Berikut adalah penjelasan dari masing-masing kategori kerusakan:

#### - **Rusak Berat** 💔

#### Kategori ini mencakup gambar bangunan yang telah mengalami kerusakan total atau hampir total.

#### 🔸 Struktur utama seperti dinding dan atap tidak lagi terlihat utuh.

####🔸 Sebagian besar bangunan rata dengan tanah akibat bencana besar, seperti gempa bumi atau angin kencang.

####🔸 Bangunan dalam kondisi ini tidak dapat diperbaiki lagi.

#### - **Rusak Menengah** 🏚️

#### Kategori ini mencakup gambar bangunan yang mengalami kerusakan signifikan.

####🔸 Dinding dengan retakan besar, atap yang sebagian runtuh, atau struktur yang mulai rapuh.

####🔸 Bentuk dasar bangunan masih terlihat, namun memerlukan perbaikan besar untuk mencegah kerusakan lebih lanjut.

####🔸 Kategori ini membutuhkan perhatian khusus untuk memastikan keamanan.

####- **Rusak Ringan** 🔨

#### Kategori ini berisi gambar bangunan dengan kerusakan kecil atau estetika.

####🔸 Retakan ringan pada dinding atau plafon yang rusak sebagian.

####🔸 Bangunan tetap dapat digunakan tanpa risiko besar.

####🔸 Perbaikan yang diperlukan hanya bersifat minor.

#### Dengan dataset representatif dari ketiga kategori tersebut, sistem kami dilatih untuk mengenali dan mengklasifikasikan tingkat kerusakan bangunan dengan akurasi tinggi.

# <a id='5' href=#1 ><h1 style="font-family: garamond; font-size: 40px; font-style: normal; letter-spacing: 3px; background-color: #f6f5f5; color: #003f88; border-radius: 50px; padding: 10px 20px; text-align: center; box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);">Import Libraries 🧰
"""

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
import numpy as np
import os
import shutil
from sklearn.model_selection import train_test_split
from google.colab import files
from collections import Counter
import zipfile
from PIL import Image
from tensorflow.keras.preprocessing import image
from sklearn.model_selection import train_test_split
from google.colab import files

"""# <a id='5' href=#1 ><h1 style="font-family: garamond; font-size: 40px; font-style: normal; letter-spacing: 3px; background-color: #f6f5f5; color: #003f88; border-radius: 50px; padding: 10px 20px; text-align: center; box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);">#️⃣ Dataset Preparation & Loading 💾</h1></a>

## Dataset yang digunakan dalam proyek ini disediakan dalam bentuk file ZIP yang berisi gambar-gambar yang telah dikelompokkan ke dalam tiga kategori utama, yaitu Rusak Berat, Rusak Menengah, dan Rusak Ringan. Setiap kategori merepresentasikan tingkat kerusakan tertentu, dengan tujuan untuk melatih model deteksi kerusakan bangunan agar dapat mengenali pola visual dari masing-masing kondisi.
"""

# Path file ZIP dan folder tujuan ekstraksi
zip_path = "/content/dataset_gambar.zip"
extract_path = "/content/dataset_gambar"

# Langkah 1: Ekstrak file ZIP
if os.path.exists(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_path)
    print(f"File ZIP berhasil diekstrak ke: {extract_path}")
else:
    print("File ZIP tidak ditemukan!")

# Langkah 2: Periksa isi folder utama
if os.path.exists(extract_path):
    print(f"Isi folder {extract_path}: {os.listdir(extract_path)}")
else:
    print(f"Folder {extract_path} tidak ditemukan!")

# Langkah 3: Pindahkan subfolder dari 'dataset_gambar' ke folder utama
inner_folder = os.path.join(extract_path, "dataset_gambar")
if os.path.exists(inner_folder) and os.path.isdir(inner_folder):
    for subfolder in os.listdir(inner_folder):
        subfolder_path = os.path.join(inner_folder, subfolder)
        if os.path.isdir(subfolder_path):
            shutil.move(subfolder_path, extract_path)  # Pindahkan ke folder utama
            print(f"Folder '{subfolder}' berhasil dipindahkan ke folder utama.")

    # Setelah memindahkan subfolder, hapus folder 'dataset_gambar'
    shutil.rmtree(inner_folder)
    print(f"Folder '{inner_folder}' berhasil dihapus.")
else:
    print(f"Folder '{inner_folder}' tidak ditemukan atau bukan folder!")

# Langkah 4: Verifikasi hasil akhir
print(f"Isi folder {extract_path} setelah penghapusan: {os.listdir(extract_path)}")

"""# <a id='5' href=#1 ><h1 style = "font-family: garamond; font-size: 40px; font-style: normal; letter-spcaing: 3px; background-color: #f6f5f5; color :#003f88; border-radius: 100px 100px; text-align:center;">Exploratory Data Analysis (EDA) 📊</h1><a/>"""

def plot_images_by_single_class(base_path, class_name, num_images=5):
    class_path = os.path.join(base_path, class_name)
    if not os.path.exists(class_path):
        raise FileNotFoundError(f"Path '{class_path}' tidak ditemukan.")

    # Ambil file gambar
    images = [os.path.join(class_path, file) for file in os.listdir(class_path) if os.path.isfile(os.path.join(class_path, file))]

    # Pastikan jumlah gambar tidak melebihi jumlah file tersedia
    num_images = min(num_images, len(images))

    # Plot gambar
    plt.figure(figsize=(15, 5))
    for i in range(num_images):
        img = Image.open(images[i])
        plt.subplot(1, num_images, i + 1)
        plt.imshow(img)
        plt.axis('off')
        plt.title(class_name)
    plt.show()

base_path = "/content/dataset_gambar"
class_name = "berat"
plot_images_by_single_class(base_path, class_name, num_images=5)

base_path = "/content/dataset_gambar"
class_name = "menengah"
plot_images_by_single_class(base_path, class_name, num_images=5)

base_path = "/content/dataset_gambar"
class_name = "ringan"
plot_images_by_single_class(base_path, class_name, num_images=5)

# Hitung jumlah gambar per kategori
categories = ["berat", "menengah", "ringan"]
file_counts = []

for category in categories:
    folder_path = os.path.join(base_path, category)
    file_counts.append(len(os.listdir(folder_path)))

# Visualisasi jumlah gambar
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.bar(categories, file_counts, color='skyblue')
plt.xlabel('Kategori')
plt.ylabel('Jumlah Gambar')
plt.title('Jumlah Gambar per Kategori')
plt.show()

# Filter untuk file gambar
valid_extensions = (".jpg", ".jpeg", ".png")

image_sizes = {}

for category in categories:
    folder_path = os.path.join(base_path, category)
    sizes = []
    for img_file in os.listdir(folder_path):
        img_path = os.path.join(folder_path, img_file)
        # Pastikan hanya file gambar yang diproses
        if os.path.isfile(img_path) and img_file.lower().endswith(valid_extensions):
            with Image.open(img_path) as img:
                sizes.append(img.size)
    image_sizes[category] = sizes

# Tampilkan ukuran gambar untuk setiap kategori
for category, sizes in image_sizes.items():
    print(f"Kategori '{category}' memiliki ukuran gambar: {sizes[:5]} ")

# Fungsi untuk menghitung rata-rata warna
def calculate_average_color(image_path):
    with Image.open(image_path) as img:
        img_array = np.array(img)
        avg_color = img_array.mean(axis=(0, 1))
        return avg_color

# Path ke folder dataset
base_path = "/content/dataset_gambar"
categories = ["berat", "menengah", "ringan"]

average_colors = {}

# Iterasi setiap kategori
for category in categories:
    folder_path = os.path.join(base_path, category)
    avg_colors = []
    for img_file in os.listdir(folder_path):
        img_path = os.path.join(folder_path, img_file)
        if os.path.isfile(img_path) and img_file.lower().endswith(('.jpg', '.jpeg', '.png')):
            avg_colors.append(calculate_average_color(img_path))
    average_colors[category] = avg_colors

# Tampilkan rata-rata warna untuk setiap kategori
for category, colors in average_colors.items():
    print(f"Kategori '{category}' memiliki rata-rata warna: {colors[:5]} (contoh)")

valid_extensions = (".jpg", ".jpeg", ".png")

dimensions = {}

for category in categories:
    folder_path = os.path.join(base_path, category)
    dims = []
    for img_file in os.listdir(folder_path):
        img_path = os.path.join(folder_path, img_file)
        # Abaikan jika bukan file atau jika bukan file gambar
        if os.path.isdir(img_path) or not img_file.lower().endswith(valid_extensions):
            continue
        try:
            with Image.open(img_path) as img:
                dims.append(img.size)
        except Exception as e:
            print(f"Error membuka file {img_path}: {e}")
    dimensions[category] = Counter(dims)

# Tampilkan distribusi dimensi untuk setiap kategori
for category, dim_counter in dimensions.items():
    print(f"Kategori '{category}': {dim_counter}")

"""# <a id='splitting' href=#splitting>
<h1 style="font-family: Garamond; font-size: 40px; font-style: normal; letter-spacing: 3px;
background-color: #f6f5f5; color: #003f88; border-radius: 100px 100px; text-align: center;">
Dataset Splitting 🗂️
</h1>
</a>

"""

data_path = "dataset_gambar"
output_path = "splitted_dataset"

# Buat folder untuk train, val, test
if not os.path.exists(output_path):
    os.makedirs(output_path)
    os.makedirs(os.path.join(output_path, "train"))
    os.makedirs(os.path.join(output_path, "val"))
    os.makedirs(os.path.join(output_path, "test"))

# Fungsi untuk mengecek file gambar
def is_image_file(filename):
    valid_extensions = (".jpg", ".jpeg", ".png", ".bmp", ".gif")
    return filename.lower().endswith(valid_extensions)

# Bagi dataset
for class_name in os.listdir(data_path):
    class_path = os.path.join(data_path, class_name)
    if not os.path.isdir(class_path):
        continue  # Lewati jika bukan folder

    # Ambil hanya file gambar
    images = [img for img in os.listdir(class_path) if is_image_file(img)]
    print(f"Folder {class_path} memiliki {len(images)} gambar.")
    if len(images) == 0:
        print(f"Tidak ada file gambar di folder {class_path}, dilewati.")
        continue

    # Split dataset menjadi train, val, test
    train, test = train_test_split(images, test_size=0.1, random_state=42)
    train, val = train_test_split(train, test_size=0.2, random_state=42)

    # Copy data ke folder masing-masing
    for split, split_name in zip([train, val, test], ["train", "val", "test"]):
        split_dir = os.path.join(output_path, split_name, class_name)
        os.makedirs(split_dir, exist_ok=True)
        for img in split:
            shutil.copy(os.path.join(class_path, img), os.path.join(split_dir, img))

print("Dataset berhasil dibagi menjadi train, val, dan test.")

"""# <a id='splitting' href=#splitting>
<h1 style="font-family: Garamond; font-size: 40px; font-style: normal; letter-spacing: 3px;
background-color: #f6f5f5; color: #003f88; border-radius: 100px 100px; text-align: center;">
Preprocessing 🔄
</h1>
</a>

"""

# Path dataset split
train_path = "splitted_dataset/train"
val_path = "splitted_dataset/val"
test_path = "splitted_dataset/test"

# Data Augmentation
datagen = ImageDataGenerator(
    rescale=1.0/255,
    rotation_range=30,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode="nearest"
)

test_datagen = ImageDataGenerator(rescale=1.0/255)

# Data Generator
train_gen = datagen.flow_from_directory(
    directory=train_path,
    target_size=(128, 128),
    batch_size=32,
    class_mode="categorical"
)

val_gen = datagen.flow_from_directory(
    directory=val_path,
    target_size=(128, 128),
    batch_size=32,
    class_mode="categorical"
)

test_gen = test_datagen.flow_from_directory(
    directory=test_path,
    target_size=(128, 128),
    batch_size=32,
    class_mode="categorical",
    shuffle=False
)

"""# <a id='splitting' href=#splitting>
<h1 style="font-family: Garamond; font-size: 40px; font-style: normal; letter-spacing: 3px;
background-color: #f6f5f5; color: #003f88; border-radius: 100px 100px; text-align: center;">
Model Training 🚀
</h1>
</a>

"""

# Model MobileNetV2
base_model = MobileNetV2(weights="imagenet", include_top=False, input_shape=(128, 128, 3))
base_model.trainable = False

model = Sequential([
    base_model,
    GlobalAveragePooling2D(),
    Dropout(0.5),
    Dense(128, activation='relu'),
    Dropout(0.3),
    Dense(train_gen.num_classes, activation='softmax')
])

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# Pelatihan Model
history = model.fit(train_gen, validation_data=val_gen, epochs=25)

# Visualisasi Train Loss
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.legend()
plt.title("Train vs Val Loss")
plt.show()

#Visualisasi Akurasi
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.legend()
plt.title("Train vs Val Accuracy")
plt.show()

"""# <a id='splitting' href=#splitting>
<h1 style="font-family: Garamond; font-size: 40px; font-style: normal; letter-spacing: 3px;
background-color: #f6f5f5; color: #003f88; border-radius: 100px 100px; text-align: center;">
Model Evaluation 🧪
"""

# Evaluasi Model pada Test Dataset
print("Evaluasi pada Test Dataset...")
test_preds = model.predict(test_gen)
test_preds_classes = np.argmax(test_preds, axis=1)
true_classes = test_gen.classes

# Confusion Matrix
cm = confusion_matrix(true_classes, test_preds_classes)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=test_gen.class_indices.keys())
disp.plot(cmap='Blues')
plt.title("Confusion Matrix - Test Dataset")
plt.show()

# Classification Report
report = classification_report(true_classes, test_preds_classes, target_names=test_gen.class_indices.keys())
print("Classification Report - Test Dataset:")
print(report)

"""
# <a id='splitting' href=#splitting>
<h1 style="font-family: Garamond; font-size: 40px; font-style: normal; letter-spacing: 3px;
background-color: #f6f5f5; color: #003f88; border-radius: 100px 100px; text-align: center;">Image Prediction 🖼️</h1></a>"""

IMG_SIZE = 128

# Fungsi untuk memprediksi gambar dengan visualisasi
def predict_image_with_visualization(model, image_path, class_labels):
    img = image.load_img(image_path, target_size=(IMG_SIZE, IMG_SIZE))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    predictions = model.predict(img_array)
    predicted_index = np.argmax(predictions)
    confidence = predictions[0][predicted_index]

    # Visualisasi gambar dengan prediksi
    plt.imshow(img)
    plt.axis("off")
    plt.title(f"Prediksi: {class_labels[predicted_index]} ({confidence:.2f})")
    plt.show()

    return class_labels[predicted_index], confidence

# Upload gambar baru untuk diprediksi
uploaded = files.upload()

for filename in uploaded.keys():
    label, confidence = predict_image_with_visualization(
        model,
        filename,
        list(train_gen.class_indices.keys())
    )
    print(f"Gambar: {filename} -> Prediksi: {label} (Confidence: {confidence:.4f})")

from tensorflow.keras.preprocessing import image
from google.colab import files
import numpy as np
import matplotlib.pyplot as plt

IMG_SIZE = 128  # Ukuran gambar yang digunakan dalam pelatihan

# Fungsi untuk memprediksi gambar dengan visualisasi
def predict_image_with_visualization(model, image_path, class_labels):
    img = image.load_img(image_path, target_size=(IMG_SIZE, IMG_SIZE))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    predictions = model.predict(img_array)
    predicted_index = np.argmax(predictions)
    confidence = predictions[0][predicted_index]

    # Visualisasi gambar dengan prediksi
    plt.imshow(img)
    plt.axis("off")
    plt.title(f"Prediksi: {class_labels[predicted_index]} ({confidence:.2f})")
    plt.show()

    return class_labels[predicted_index], confidence

# Upload gambar baru untuk diprediksi
uploaded = files.upload()

# Ganti `best_model` dengan model yang sudah dilatih, yaitu `model`
for filename in uploaded.keys():
    label, confidence = predict_image_with_visualization(
        model,  # Menggunakan model yang dilatih sebelumnya
        filename,
        list(train_gen.class_indices.keys())
    )
    print(f"Gambar: {filename} -> Prediksi: {label} (Confidence: {confidence:.4f})")

IMG_SIZE = 128  # Ukuran gambar yang digunakan dalam pelatihan

# Fungsi untuk memprediksi gambar dengan visualisasi
def predict_image_with_visualization(model, image_path, class_labels):
    img = image.load_img(image_path, target_size=(IMG_SIZE, IMG_SIZE))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    predictions = model.predict(img_array)
    predicted_index = np.argmax(predictions)
    confidence = predictions[0][predicted_index]

    # Visualisasi gambar dengan prediksi
    plt.imshow(img)
    plt.axis("off")
    plt.title(f"Prediksi: {class_labels[predicted_index]} ({confidence:.2f})")
    plt.show()

    return class_labels[predicted_index], confidence

# Upload gambar baru untuk diprediksi
uploaded = files.upload()

# Ganti `best_model` dengan model yang sudah dilatih, yaitu `model`
for filename in uploaded.keys():
    label, confidence = predict_image_with_visualization(
        model,  # Menggunakan model yang dilatih sebelumnya
        filename,
        list(train_gen.class_indices.keys())
    )
    print(f"Gambar: {filename} -> Prediksi: {label} (Confidence: {confidence:.4f})")

model.save("model_klasifikasirumah.h5")